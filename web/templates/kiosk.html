<!DOCTYPE html>
<html lang="nl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NetMonitor SOC - Kiosk Mode</title>
    <!-- Chart.js for traffic visualization -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <style>
        /* ==================== CSS Variables for Theming ==================== */
        :root[data-theme="dark"] {
            --bg-primary: #0f172a;
            --bg-secondary: #1e293b;
            --bg-card: #334155;
            --text-primary: #f1f5f9;
            --text-secondary: #cbd5e1;
            --text-muted: #94a3b8;
            --border-color: #475569;
            --accent-primary: #3b82f6;
            --accent-success: #10b981;
            --accent-warning: #f59e0b;
            --accent-danger: #ef4444;
            --shadow: rgba(0, 0, 0, 0.5);
        }

        :root[data-theme="light"] {
            --bg-primary: #f8fafc;
            --bg-secondary: #ffffff;
            --bg-card: #ffffff;
            --text-primary: #0f172a;
            --text-secondary: #475569;
            --text-muted: #64748b;
            --border-color: #e2e8f0;
            --accent-primary: #3b82f6;
            --accent-success: #10b981;
            --accent-warning: #f59e0b;
            --accent-danger: #ef4444;
            --shadow: rgba(0, 0, 0, 0.1);
        }

        /* ==================== Base Styles ==================== */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
                'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
                sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            overflow-x: hidden;
            transition: background 0.3s ease, color 0.3s ease;
        }

        /* ==================== Container & Layout ==================== */
        .kiosk-container {
            max-width: 100vw;
            min-height: 100vh;
            padding: 1rem;
        }

        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
            padding: 1rem;
            background: var(--bg-secondary);
            border-radius: 0.5rem;
            border: 1px solid var(--border-color);
        }

        .header h1 {
            font-size: 2rem;
            font-weight: 700;
            color: var(--accent-primary);
        }

        .header-controls {
            display: flex;
            gap: 1rem;
            align-items: center;
        }

        .status-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: var(--accent-success);
            animation: pulse 2s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .timestamp {
            color: var(--text-muted);
            font-size: 0.875rem;
        }

        /* ==================== Controls ==================== */
        .controls {
            display: flex;
            gap: 0.5rem;
        }

        .btn {
            padding: 0.5rem 1rem;
            border: none;
            border-radius: 0.375rem;
            font-size: 0.875rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            background: var(--bg-card);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
        }

        .btn:hover {
            background: var(--accent-primary);
            color: white;
            transform: translateY(-1px);
        }

        .btn-icon {
            padding: 0.5rem;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* ==================== Grid Layout ==================== */
        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 1.5rem;
            margin-bottom: 2rem;
            min-height: 200px; /* Prevent layout shift */
        }

        /* Carousel animations */
        .metrics-grid .card {
            opacity: 0;
            transform: scale(0.95);
            transition: opacity 0.5s ease, transform 0.5s ease;
        }

        .metrics-grid .card.visible {
            opacity: 1;
            transform: scale(1);
        }

        /* Page indicator */
        .carousel-indicator {
            display: flex;
            justify-content: center;
            gap: 0.5rem;
            margin-bottom: 1rem;
        }

        .carousel-indicator .dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: var(--text-muted);
            opacity: 0.3;
            transition: opacity 0.3s ease, background 0.3s ease;
        }

        .carousel-indicator .dot.active {
            opacity: 1;
            background: var(--accent-primary);
        }

        @media (max-width: 1024px) {
            .metrics-grid {
                grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            }
        }

        /* ==================== Cards ==================== */
        .card {
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 0.75rem;
            padding: 1.5rem;
            box-shadow: 0 4px 6px var(--shadow);
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }

        .card:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 12px var(--shadow);
        }

        .card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
        }

        .card-title {
            font-size: 0.875rem;
            font-weight: 600;
            text-transform: uppercase;
            color: var(--text-muted);
            letter-spacing: 0.05em;
        }

        .card-icon {
            font-size: 1.5rem;
        }

        .card-value {
            font-size: 2.5rem;
            font-weight: 700;
            color: var(--text-primary);
            line-height: 1;
            margin-bottom: 0.5rem;
        }

        .card-label {
            font-size: 0.75rem;
            color: var(--text-muted);
        }

        /* ==================== Status Colors ==================== */
        .status-online { color: var(--accent-success); }
        .status-warning { color: var(--accent-warning); }
        .status-offline { color: var(--accent-danger); }
        .status-critical { color: var(--accent-danger); }

        .bg-online { background: var(--accent-success); }
        .bg-warning { background: var(--accent-warning); }
        .bg-offline { background: var(--accent-danger); }
        .bg-critical { background: var(--accent-danger); }

        /* ==================== Screen Views ==================== */
        .traffic-container {
            display: none;
        }

        .traffic-container.active {
            display: block;
        }

        .threats-container {
            display: none;
        }

        .threats-container.active {
            display: block;
        }

        .alerts-container {
            display: none;
        }

        .alerts-container.active {
            display: block;
        }

        #alerts-list {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 1rem;
        }

        .alert-item {
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-left: 4px solid var(--accent-danger);
            border-radius: 0.5rem;
            padding: 1rem;
            margin-bottom: 0; /* Remove bottom margin, using gap instead */
            transition: all 0.2s ease;
        }

        .alert-item:hover {
            transform: translateX(4px);
            border-left-width: 6px;
        }

        .alert-item.severity-HIGH {
            border-left-color: var(--accent-warning);
        }

        .alert-item.severity-CRITICAL {
            border-left-color: var(--accent-danger);
        }

        .alert-header {
            display: flex;
            justify-content: space-between;
            align-items: start;
            margin-bottom: 0.5rem;
        }

        .alert-type {
            font-weight: 700;
            font-size: 1rem;
            color: var(--text-primary);
        }

        .alert-severity {
            padding: 0.25rem 0.75rem;
            border-radius: 0.25rem;
            font-size: 0.75rem;
            font-weight: 700;
            text-transform: uppercase;
        }

        .alert-severity.HIGH {
            background: var(--accent-warning);
            color: white;
        }

        .alert-severity.CRITICAL {
            background: var(--accent-danger);
            color: white;
        }

        .alert-description {
            color: var(--text-secondary);
            font-size: 0.875rem;
            margin-bottom: 0.5rem;
        }

        .alert-meta {
            display: flex;
            gap: 1rem;
            font-size: 0.75rem;
            color: var(--text-muted);
        }

        /* ==================== Sensors View ==================== */
        .sensors-container {
            display: none;
        }

        .sensors-container.active {
            display: block;
        }

        .sensors-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: 1rem;
        }

        .sensor-card {
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 0.5rem;
            padding: 1rem;
            transition: all 0.2s ease;
        }

        .sensor-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px var(--shadow);
        }

        .sensor-card.online {
            border-left: 4px solid var(--accent-success);
        }

        .sensor-card.warning {
            border-left: 4px solid var(--accent-warning);
        }

        .sensor-card.offline {
            border-left: 4px solid var(--accent-danger);
        }

        .sensor-name {
            font-weight: 700;
            font-size: 1rem;
            margin-bottom: 0.25rem;
            color: var(--text-primary);
        }

        .sensor-location {
            font-size: 0.75rem;
            color: var(--text-muted);
            margin-bottom: 0.75rem;
        }

        .sensor-stats {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 0.5rem;
            margin-top: 0.75rem;
        }

        .sensor-stat {
            display: flex;
            flex-direction: column;
        }

        .sensor-stat-label {
            font-size: 0.625rem;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .sensor-stat-value {
            font-size: 0.875rem;
            font-weight: 600;
            color: var(--text-primary);
        }

        /* ==================== Fullscreen Hint ==================== */
        .fullscreen-hint {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 2rem 3rem;
            border-radius: 1rem;
            text-align: center;
            z-index: 1000;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }

        .fullscreen-hint.show {
            opacity: 1;
            pointer-events: auto;
        }

        .fullscreen-hint h2 {
            font-size: 2rem;
            margin-bottom: 1rem;
        }

        .fullscreen-hint p {
            font-size: 1.25rem;
            color: #cbd5e1;
        }

        .fullscreen-hint kbd {
            display: inline-block;
            padding: 0.5rem 1rem;
            background: #334155;
            border-radius: 0.375rem;
            font-size: 1.5rem;
            font-weight: 700;
            margin: 0 0.25rem;
        }

        /* ==================== Rotation Progress Bar ==================== */
        .rotation-progress {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: var(--border-color);
            z-index: 999;
            overflow: hidden;
        }

        .rotation-progress-bar {
            height: 100%;
            background: linear-gradient(90deg, var(--accent-primary), var(--accent-success));
            width: 0%;
            transition: width 0.1s linear;
        }

        /* ==================== Screen Indicator ==================== */
        .screen-indicator {
            display: flex;
            gap: 0.5rem;
            justify-content: center;
            margin-top: 1rem;
        }

        .screen-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: var(--border-color);
            transition: all 0.3s ease;
        }

        .screen-dot.active {
            background: var(--accent-primary);
            transform: scale(1.3);
        }

        /* ==================== Critical Alert Flash ==================== */
        @keyframes criticalFlash {
            0%, 100% { background: var(--bg-primary); }
            50% { background: rgba(239, 68, 68, 0.2); }
        }

        body.critical-flash {
            animation: criticalFlash 0.5s ease-in-out 3;
        }

        /* ==================== Trend Indicators ==================== */
        .trend-indicator {
            display: inline-block;
            margin-left: 0.5rem;
            font-size: 0.875rem;
        }

        .trend-up {
            color: var(--accent-success);
        }

        .trend-down {
            color: var(--accent-danger);
        }

        .trend-stable {
            color: var(--text-muted);
        }

        /* ==================== Location Groups ==================== */
        .location-groups {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
            margin-bottom: 1rem;
        }

        .location-group {
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 0.5rem;
            padding: 1rem;
        }

        .location-group .sensors-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
            gap: 0.75rem;
            margin-top: 0.75rem;
        }

        .location-group-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.5rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid var(--border-color);
        }

        .location-name {
            font-weight: 700;
            font-size: 0.875rem;
            color: var(--text-primary);
        }

        .location-count {
            font-size: 0.75rem;
            color: var(--text-muted);
        }

        /* ==================== Threat Breakdown ==================== */
        .threat-breakdown {
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 0.75rem;
            padding: 1.5rem;
            margin-bottom: 2rem;
        }

        .threat-breakdown-title {
            font-size: 1.25rem;
            font-weight: 700;
            color: var(--text-primary);
            margin-bottom: 1rem;
        }

        .threat-list {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 0.75rem;
        }

        .threat-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0.75rem;
            background: var(--bg-secondary);
            border-radius: 0.5rem;
            transition: all 0.2s ease;
        }

        .threat-item:hover {
            transform: translateX(4px);
            background: var(--bg-primary);
        }

        .threat-info {
            display: flex;
            align-items: center;
            gap: 1rem;
            flex: 1;
        }

        .threat-icon {
            font-size: 1.5rem;
        }

        .threat-details {
            flex: 1;
        }

        .threat-name {
            font-weight: 600;
            font-size: 0.875rem;
            color: var(--text-primary);
            margin-bottom: 0.25rem;
        }

        .threat-bar {
            height: 4px;
            background: var(--border-color);
            border-radius: 2px;
            overflow: hidden;
            margin-top: 0.25rem;
        }

        .threat-bar-fill {
            height: 100%;
            background: var(--accent-danger);
            transition: width 0.3s ease;
        }

        .threat-count {
            font-size: 1.25rem;
            font-weight: 700;
            color: var(--accent-danger);
            min-width: 60px;
            text-align: right;
        }

        /* ==================== Loading State ==================== */
        .loading {
            text-align: center;
            padding: 2rem;
            color: var(--text-muted);
        }

        .spinner {
            border: 3px solid var(--border-color);
            border-top: 3px solid var(--accent-primary);
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 1rem;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* ==================== Traffic Chart ==================== */
        .traffic-chart-container {
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 0.75rem;
            padding: 1.5rem;
            margin-bottom: 2rem;
            box-shadow: 0 4px 6px var(--shadow);
        }

        .traffic-chart-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
        }

        .traffic-chart-title {
            font-size: 1.25rem;
            font-weight: 700;
            color: var(--text-primary);
        }

        .traffic-chart-legend {
            display: flex;
            gap: 1.5rem;
            font-size: 0.875rem;
        }

        .traffic-legend-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .traffic-legend-color {
            width: 16px;
            height: 16px;
            border-radius: 3px;
        }

        #trafficChart {
            max-height: 300px;
        }

        /* ==================== Responsive ==================== */
        @media (max-width: 768px) {
            .header h1 {
                font-size: 1.5rem;
            }

            .metrics-grid {
                grid-template-columns: 1fr;
            }

            .sensors-grid {
                grid-template-columns: 1fr;
            }

            .traffic-chart-header {
                flex-direction: column;
                align-items: flex-start;
                gap: 0.5rem;
            }

            #trafficChart {
                max-height: 250px;
            }
        }
    </style>
</head>
<body>
    <!-- Rotation Progress Bar -->
    <div class="rotation-progress">
        <div class="rotation-progress-bar" id="rotation-progress-bar"></div>
    </div>

    <div class="kiosk-container">
        <!-- Header -->
        <div class="header">
            <h1 style="display: flex; align-items: center; gap: 0.5rem;">
                <img src="{{ url_for('static', filename='logo.png') }}" alt="NetMonitor" height="40">
                NetMonitor SOC - Kiosk
            </h1>
            <div class="header-controls">
                <div class="status-dot"></div>
                <span class="timestamp" id="timestamp">--:--:--</span>
                <div class="controls">
                    <button class="btn btn-icon" onclick="toggleTheme()" title="Toggle Theme">
                        <span id="theme-icon">üåô</span>
                    </button>
                    <button class="btn btn-icon" onclick="toggleFullscreen()" title="Fullscreen (F11)">
                        <span>‚õ∂</span>
                    </button>
                </div>
            </div>
        </div>

        <!-- Carousel Indicator -->
        <div class="carousel-indicator" id="carousel-indicator">
            <div class="dot active"></div>
            <div class="dot"></div>
            <div class="dot"></div>
        </div>

        <!-- Metrics Grid - Always Visible (3 cards per page, rotates every 10s) -->
        <div class="metrics-grid" id="metrics-grid">
            <!-- Metrics cards will be populated by JavaScript -->
            <div class="loading">
                <div class="spinner"></div>
                <p>Loading metrics...</p>
            </div>
        </div>

        <!-- Traffic Chart Screen - Page 1 Only -->
        <div id="screen-traffic" class="traffic-container active">
            <div class="traffic-chart-container">
                <div class="traffic-chart-header">
                    <h3 class="traffic-chart-title">üìä Network Traffic - Last 24 Hours</h3>
                    <div class="traffic-chart-legend">
                        <div class="traffic-legend-item">
                            <div class="traffic-legend-color" style="background: #3b82f6;"></div>
                            <span>Inbound</span>
                        </div>
                        <div class="traffic-legend-item">
                            <div class="traffic-legend-color" style="background: #10b981;"></div>
                            <span>Outbound</span>
                        </div>
                    </div>
                </div>
                <canvas id="trafficChart"></canvas>
            </div>
        </div>

        <!-- Top Threats Screen - Page 2 Only -->
        <div id="screen-threats" class="threats-container">
            <div class="threat-breakdown">
                <h3 class="threat-breakdown-title">üéØ Top Threats - Last 24 Hours</h3>
                <div class="threat-list" id="threat-list">
                    <!-- Will be populated by JavaScript -->
                    <div class="loading">
                        <div class="spinner"></div>
                        <p>Loading threat data...</p>
                    </div>
                </div>
            </div>
        </div>

        <!-- Alerts Screen - Page 3 Only -->
        <div id="screen-alerts" class="alerts-container">
            <h2 style="margin-bottom: 1rem; font-size: 1.5rem;">‚ö†Ô∏è Critical & High Severity Alerts</h2>
            <div id="alerts-list">
                <!-- Alerts will be populated by JavaScript -->
            </div>
        </div>

        <!-- Sensors Screen -->
        <div id="screen-sensors" class="sensors-container">
            <h2 style="margin-bottom: 1rem; font-size: 1.5rem;">üì° Sensor Status</h2>

            <!-- Location Groups -->
            <div class="location-groups" id="location-groups">
                <!-- Will be populated by JavaScript with sensors grouped by location -->
            </div>
        </div>

        <!-- Screen Indicator -->
        <div class="screen-indicator">
            <div class="screen-dot active" data-screen="0"></div>
            <div class="screen-dot" data-screen="1"></div>
            <div class="screen-dot" data-screen="2"></div>
            <div class="screen-dot" data-screen="3"></div>
        </div>
    </div>

    <!-- Fullscreen Hint -->
    <div class="fullscreen-hint" id="fullscreen-hint">
        <h2>Kiosk Mode</h2>
        <p>Press <kbd>F11</kbd> for fullscreen</p>
        <p style="margin-top: 1rem; font-size: 1rem;">This message will auto-hide in 5 seconds</p>
    </div>

    <script>
        // ==================== Configuration ====================
        const CONFIG = {
            refreshInterval: 5000,      // 5 seconds
            rotationInterval: 30000,    // 30 seconds
            hintDuration: 5000,         // 5 seconds
            criticalAlertSound: true,   // Enable/disable sound
            progressBarUpdate: 100      // Progress bar update interval (ms)
        };

        // ==================== State ====================
        let currentScreen = 0;
        let rotationTimer = null;
        let refreshTimer = null;
        let progressTimer = null;
        let rotationStartTime = Date.now();
        let lastAlertCount = 0;
        let previousMetrics = {};  // For trend calculation

        // ==================== Alert Sound ====================
        const alertSound = new Audio('data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVFApGn+DyvmwhBSuBzvLZiTYHGGS67OyXVA4NTann8rxkHAU3kdfw0H4yBSl+zPLaizsKFV6z6uykVxILSKDh8bllHgU1gMrw3Ik3Bxhku+zumlYODUypqeuZVRALRZ7f8btmIAU3kdfw0IIzBSh+zPLbjDsKFl205uqlWRILR5/h8bpmIAU2gcvx3os4BxlluuzunVkODUyrqOyXVRALRZ/g8L5mIAU3gtPx0YQ0BSh/zfPcjz0KFV605+unWhQJhqDi8rtnIgU4g9Xx0IU1BSh/zvPdjT0KFV605+uoXBQLSKLj87xnIwU6hNLx0IY1Byx/z/PejD0KFV+06eypYBUIh6Li8r1mIgU6hNLy0oY2Byx/z/XejD0KFV+06eupYhUGh6Lj8r5mIwU8hNHz0YY1Byx/z/Xej D0KFV+06eupYBUIh6Li8r1mIgU6hNLy0oY2Byx/z/XejD0KFV+06eupYhUGh6Lj8r5mIwU8hNHz0YY1Byx/z/Xej0');

        // Threat type icons - map database threat types to icons
        const THREAT_ICONS = {
            // Database naming (UPPERCASE_WITH_UNDERSCORES)
            'PORT_SCAN': 'üîç',
            'BRUTE_FORCE_ATTEMPT': 'üî®',
            'BRUTE_FORCE': 'üî®',
            'DDOS': 'üí•',
            'DDOS_ATTACK': 'üí•',
            'MALWARE': 'ü¶†',
            'MALWARE_DETECTED': 'ü¶†',
            'EXPLOIT': '‚ö°',
            'EXPLOIT_ATTEMPT': '‚ö°',
            'BEACONING_DETECTED': 'üì°',
            'BEACONING': 'üì°',
            'DNS_TUNNEL_SUSPICIOUS_LENGTH': 'üåê',
            'DNS_TUNNEL': 'üåê',
            'UNUSUAL_PACKET_SIZE': 'üì¶',
            'UNUSUAL_TRAFFIC': 'üìä',
            'SUSPICIOUS_ACTIVITY': '‚ö†Ô∏è',
            'ANOMALY': '‚ö†Ô∏è',
            'PHISHING': 'üé£',
            'UNKNOWN': '‚ùì',

            // TLS/SSL threat types
            'TLS_WEAK_CIPHER_OFFERED': 'üîì',
            'TLS_MISSING_SNI': 'üîê',
            'TLS_EXPIRED_CERT': 'üìú',
            'TLS_SELF_SIGNED': 'üìù',
            'TLS_INVALID_CERT': '‚ùå',
            'TLS_WEAK_PROTOCOL': 'üîì',
            'TLS_SUSPICIOUS_JA3': 'üïµÔ∏è',
            'SSL_STRIPPING': '‚õìÔ∏è',

            // Network threat types
            'LATERAL_MOVEMENT': '‚ÜîÔ∏è',
            'CONNECTION_FLOOD': 'üåä',
            'PROTOCOL_MISMATCH': 'üîÄ',
            'ICMP_TUNNEL': 'üßä',
            'OUTBOUND_VOLUME': 'üì§',
            'HTTP_ANOMALY': 'üåç',
            'SMTP_FTP_TRANSFER': 'üìß',
            'THREAT_FEED_MATCH': 'üéØ',
            'C2_COMMUNICATION': 'üëæ',
            'BLACKLISTED_IP': 'üö´',

            // Legacy naming (Title Case With Spaces) - for backwards compatibility
            'Port Scan': 'üîç',
            'Brute Force': 'üî®',
            'DDoS': 'üí•',
            'Malware': 'ü¶†',
            'Exploit': '‚ö°',
            'Anomaly': '‚ö†Ô∏è',
            'Phishing': 'üé£',
            'Tls Weak Cipher Offered': 'üîì',
            'Tls Missing Sni': 'üîê',
            'Tls Expired Cert': 'üìú',
            'Tls Self Signed': 'üìù',
            'Lateral Movement': '‚ÜîÔ∏è',
            'Connection Flood': 'üåä',
            'Protocol Mismatch': 'üîÄ',
            'Threat Feed Match': 'üéØ',
            'C2 Communication': 'üëæ'
        };

        // ==================== Theme Management ====================
        function initTheme() {
            const savedTheme = localStorage.getItem('kiosk-theme') || 'dark';
            document.documentElement.setAttribute('data-theme', savedTheme);
            updateThemeIcon(savedTheme);
        }

        function toggleTheme() {
            const current = document.documentElement.getAttribute('data-theme');
            const next = current === 'dark' ? 'light' : 'dark';
            document.documentElement.setAttribute('data-theme', next);
            localStorage.setItem('kiosk-theme', next);
            updateThemeIcon(next);

            // Redraw traffic chart with new theme colors
            if (trafficChart) {
                fetchTrafficData();
            }
        }

        function updateThemeIcon(theme) {
            document.getElementById('theme-icon').textContent = theme === 'dark' ? '‚òÄÔ∏è' : 'üåô';
        }

        // ==================== Fullscreen Management ====================
        function toggleFullscreen() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen().catch(err => {
                    console.error('Fullscreen error:', err);
                });
            } else {
                document.exitFullscreen();
            }
        }

        function showFullscreenHint() {
            const hint = document.getElementById('fullscreen-hint');
            hint.classList.add('show');
            setTimeout(() => {
                hint.classList.remove('show');
            }, CONFIG.hintDuration);
        }

        // ==================== Screen Rotation ====================
        function rotateScreen() {
            // Hide all screens
            document.querySelectorAll('[id^="screen-"]').forEach(el => el.classList.remove('active'));

            // Update current screen (cycle through 0, 1, 2, 3)
            currentScreen = (currentScreen + 1) % 4;

            // Show current screen
            const screens = ['screen-traffic', 'screen-threats', 'screen-alerts', 'screen-sensors'];
            document.getElementById(screens[currentScreen]).classList.add('active');

            // Update indicators
            document.querySelectorAll('.screen-dot').forEach((dot, index) => {
                dot.classList.toggle('active', index === currentScreen);
            });
        }

        function startRotation() {
            rotationStartTime = Date.now();
            rotationTimer = setInterval(rotateScreen, CONFIG.rotationInterval);
            startProgressBar();
        }

        function stopRotation() {
            if (rotationTimer) {
                clearInterval(rotationTimer);
                rotationTimer = null;
            }
            stopProgressBar();
        }

        function nextScreen() {
            // Advance to next screen
            rotateScreen();

            // Reset rotation timer
            stopRotation();
            startRotation();
        }

        // ==================== Progress Bar ====================
        function startProgressBar() {
            const progressBar = document.getElementById('rotation-progress-bar');
            if (!progressBar) return;

            progressTimer = setInterval(() => {
                const elapsed = Date.now() - rotationStartTime;
                const progress = Math.min((elapsed / CONFIG.rotationInterval) * 100, 100);
                progressBar.style.width = progress + '%';

                // Reset on complete
                if (progress >= 100) {
                    rotationStartTime = Date.now();
                }
            }, CONFIG.progressBarUpdate);
        }

        function stopProgressBar() {
            if (progressTimer) {
                clearInterval(progressTimer);
                progressTimer = null;
            }
        }

        // ==================== Critical Alert Detection ====================
        function checkForNewCriticalAlerts(alerts) {
            const criticalCount = alerts.filter(a => a.severity === 'CRITICAL').length;

            if (criticalCount > lastAlertCount && lastAlertCount > 0) {
                // New critical alert detected!
                triggerCriticalAlertNotification();
            }

            lastAlertCount = criticalCount;
        }

        function triggerCriticalAlertNotification() {
            // Visual flash
            document.body.classList.add('critical-flash');
            setTimeout(() => {
                document.body.classList.remove('critical-flash');
            }, 1500);

            // Play sound
            if (CONFIG.criticalAlertSound) {
                try {
                    alertSound.play().catch(e => console.log('Sound play failed:', e));
                } catch (e) {
                    console.log('Alert sound error:', e);
                }
            }
        }

        // ==================== Trend Calculation ====================
        function calculateTrend(currentValue, metricName) {
            if (!previousMetrics[metricName]) {
                previousMetrics[metricName] = currentValue;
                return 'stable';
            }

            const previous = previousMetrics[metricName];
            const diff = currentValue - previous;
            const threshold = previous * 0.1; // 10% change threshold

            previousMetrics[metricName] = currentValue;

            if (Math.abs(diff) < threshold) return 'stable';
            return diff > 0 ? 'up' : 'down';
        }

        function getTrendIndicator(trend) {
            const icons = {
                'up': '‚ÜóÔ∏è',
                'down': '‚ÜòÔ∏è',
                'stable': '‚û°Ô∏è'
            };
            return `<span class="trend-indicator trend-${trend}">${icons[trend]}</span>`;
        }

        // ==================== Data Fetching ====================
        async function fetchMetrics() {
            try {
                const response = await fetch('/api/kiosk/metrics');
                const data = await response.json();

                if (data.success) {
                    updateMetrics(data);
                    updateAlerts(data.critical_alerts || []);
                    updateThreatBreakdown(data.top_threats || {});
                    checkForNewCriticalAlerts(data.critical_alerts || []);
                }
            } catch (error) {
                console.error('Error fetching metrics:', error);
            }
        }

        async function fetchSensors() {
            try {
                const response = await fetch('/api/kiosk/sensors');
                const data = await response.json();

                if (data.success) {
                    updateSensors(data.sensors || []); // This now handles location grouping + sensor details
                }
            } catch (error) {
                console.error('Error fetching sensors:', error);
            }
        }

        // ==================== UI Updates ====================
        // Carousel state
        let currentMetricsPage = 0;
        let allMetricCards = [];
        const CARDS_PER_PAGE = 3;
        const ROTATION_INTERVAL = 10000; // 10 seconds

        function updateMetrics(data) {
            const metrics = data.metrics || {};
            const sensorHealth = data.sensor_health || {};

            // Calculate trends
            const bandwidthTrend = calculateTrend(metrics.bandwidth_mbps || 0, 'bandwidth');
            const packetsTrend = calculateTrend(metrics.packets_per_sec || 0, 'packets');
            const alertsTrend = calculateTrend(metrics.alerts_per_min || 0, 'alerts');
            const cpuTrend = calculateTrend(metrics.avg_cpu_percent || 0, 'cpu');
            const memoryTrend = calculateTrend(metrics.avg_memory_percent || 0, 'memory');

            // Build all metric cards as an array (one card per item)
            allMetricCards = [
                // Card 1: Bandwidth
                `<div class="card">
                    <div class="card-header">
                        <span class="card-title">Bandwidth</span>
                        <span class="card-icon">üìä</span>
                    </div>
                    <div class="card-value">
                        ${formatNumber(metrics.bandwidth_mbps || 0)}
                        ${getTrendIndicator(bandwidthTrend)}
                    </div>
                    <div class="card-label">Mbps Total</div>
                </div>`,
                // Card 2: Packets
                `<div class="card">
                    <div class="card-header">
                        <span class="card-title">Packets</span>
                        <span class="card-icon">üì¶</span>
                    </div>
                    <div class="card-value">
                        ${formatNumber(metrics.packets_per_sec || 0)}
                        ${getTrendIndicator(packetsTrend)}
                    </div>
                    <div class="card-label">per second</div>
                </div>`,
                // Card 3: Alerts
                `<div class="card">
                    <div class="card-header">
                        <span class="card-title">Alerts</span>
                        <span class="card-icon">‚ö†Ô∏è</span>
                    </div>
                    <div class="card-value status-${getAlertColor(metrics.alerts_per_min || 0)}">
                        ${formatNumber(metrics.alerts_per_min || 0, 2)}
                        ${getTrendIndicator(alertsTrend)}
                    </div>
                    <div class="card-label">per minute</div>
                </div>`,
                // Card 4: Sensors
                `<div class="card">
                    <div class="card-header">
                        <span class="card-title">Sensors</span>
                        <span class="card-icon">üì°</span>
                    </div>
                    <div class="card-value status-${getSensorHealthColor(sensorHealth)}">
                        ${metrics.active_sensors || '0/0'}
                    </div>
                    <div class="card-label">Online / Total</div>
                </div>`,
                // Card 5: CPU Average
                `<div class="card">
                    <div class="card-header">
                        <span class="card-title">CPU Average</span>
                        <span class="card-icon">üíª</span>
                    </div>
                    <div class="card-value status-${getResourceColor(metrics.avg_cpu_percent || 0)}">
                        ${formatNumber(metrics.avg_cpu_percent || 0, 1)}%
                        ${getTrendIndicator(cpuTrend)}
                    </div>
                    <div class="card-label">Across all sensors</div>
                </div>`,
                // Card 6: Memory Average
                `<div class="card">
                    <div class="card-header">
                        <span class="card-title">Memory Average</span>
                        <span class="card-icon">üß†</span>
                    </div>
                    <div class="card-value status-${getResourceColor(metrics.avg_memory_percent || 0)}">
                        ${formatNumber(metrics.avg_memory_percent || 0, 1)}%
                        ${getTrendIndicator(memoryTrend)}
                    </div>
                    <div class="card-label">Across all sensors</div>
                </div>`,
                // Card 7: Disk Usage
                `<div class="card">
                    <div class="card-header">
                        <span class="card-title">Disk Usage</span>
                        <span class="card-icon">üíæ</span>
                    </div>
                    <div class="card-value status-${getResourceColor(metrics.disk_percent || 0)}">
                        ${formatNumber(metrics.disk_percent || 0, 1)}%
                    </div>
                    <div class="card-label">${metrics.disk_used || '0 GB'} / ${metrics.disk_total || '0 GB'}</div>
                </div>`,
                // Card 8: Database Size
                `<div class="card">
                    <div class="card-header">
                        <span class="card-title">Database Size</span>
                        <span class="card-icon">üóÑÔ∏è</span>
                    </div>
                    <div class="card-value">
                        ${metrics.db_size_human || '0 MB'}
                    </div>
                    <div class="card-label">${formatNumber(metrics.db_alerts_count || 0)} alerts, ${formatNumber(metrics.db_metrics_count || 0)} metrics</div>
                </div>`
            ];

            // Display first page of metrics
            showMetricsPage(0);
            updateTimestamp();
        }

        function showMetricsPage(pageIndex) {
            const totalPages = Math.ceil(allMetricCards.length / CARDS_PER_PAGE);
            currentMetricsPage = pageIndex % totalPages;

            // Get cards for current page
            const startIdx = currentMetricsPage * CARDS_PER_PAGE;
            const endIdx = startIdx + CARDS_PER_PAGE;
            const pageCards = allMetricCards.slice(startIdx, endIdx);

            // Update HTML
            const metricsGrid = document.getElementById('metrics-grid');
            metricsGrid.innerHTML = pageCards.join('');

            // Trigger fade-in animation
            setTimeout(() => {
                const cards = metricsGrid.querySelectorAll('.card');
                cards.forEach((card, index) => {
                    setTimeout(() => {
                        card.classList.add('visible');
                    }, index * 100); // Stagger animation
                });
            }, 50);

            // Update page indicators
            const indicators = document.querySelectorAll('.carousel-indicator .dot');
            indicators.forEach((dot, idx) => {
                if (idx === currentMetricsPage) {
                    dot.classList.add('active');
                } else {
                    dot.classList.remove('active');
                }
            });
        }

        // Start carousel auto-rotation
        setInterval(() => {
            if (allMetricCards.length > CARDS_PER_PAGE) {
                showMetricsPage(currentMetricsPage + 1);
            }
        }, ROTATION_INTERVAL);

        function updateAlerts(alerts) {
            if (alerts.length === 0) {
                document.getElementById('alerts-list').innerHTML = `
                    <div class="card" style="text-align: center; padding: 2rem;">
                        <div style="font-size: 3rem; margin-bottom: 1rem;">‚úÖ</div>
                        <h3 style="color: var(--accent-success);">No Critical Alerts</h3>
                        <p style="color: var(--text-muted); margin-top: 0.5rem;">All systems operating normally</p>
                    </div>
                `;
                return;
            }

            const alertsHTML = alerts.map(alert => `
                <div class="alert-item severity-${alert.severity}">
                    <div class="alert-header">
                        <span class="alert-type">${escapeHtml(alert.alert_type || 'Unknown')}</span>
                        <span class="alert-severity ${alert.severity}">${alert.severity}</span>
                    </div>
                    <div class="alert-description">${escapeHtml(alert.description || 'No description')}</div>
                    <div class="alert-meta">
                        <span>üì° ${escapeHtml(alert.sensor_id || 'N/A')}</span>
                        <span>üïê ${formatTimestamp(alert.timestamp)}</span>
                        ${alert.source_ip ? `<span>üåê ${escapeHtml(alert.source_ip)}</span>` : ''}
                    </div>
                </div>
            `).join('');

            document.getElementById('alerts-list').innerHTML = alertsHTML;
        }

        function updateSensors(sensors) {
            if (sensors.length === 0) {
                document.getElementById('location-groups').innerHTML = `
                    <div class="card" style="text-align: center; padding: 2rem;">
                        <p style="color: var(--text-muted);">No sensors found</p>
                    </div>
                `;
                return;
            }

            // Group sensors by location
            const sensorsByLocation = {};
            sensors.forEach(sensor => {
                const location = sensor.location || 'Unknown Location';
                if (!sensorsByLocation[location]) {
                    sensorsByLocation[location] = [];
                }
                sensorsByLocation[location].push(sensor);
            });

            // Build HTML for location groups
            const locationsHTML = Object.entries(sensorsByLocation).map(([location, locationSensors]) => {
                const sensorsHTML = locationSensors.map(sensor => `
                    <div class="sensor-card ${sensor.status}">
                        <div class="sensor-name">${escapeHtml(sensor.name)}</div>
                        <div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.5rem;">
                            <div class="bg-${sensor.status}" style="width: 8px; height: 8px; border-radius: 50%;"></div>
                            <span style="font-size: 0.75rem; text-transform: uppercase; font-weight: 600;">
                                ${sensor.status}
                            </span>
                        </div>
                        <div class="sensor-stats">
                            <div class="sensor-stat">
                                <span class="sensor-stat-label">CPU</span>
                                <span class="sensor-stat-value">${formatNumber(sensor.cpu || 0, 1)}%</span>
                            </div>
                            <div class="sensor-stat">
                                <span class="sensor-stat-label">Memory</span>
                                <span class="sensor-stat-value">${formatNumber(sensor.memory || 0, 1)}%</span>
                            </div>
                            <div class="sensor-stat">
                                <span class="sensor-stat-label">Bandwidth</span>
                                <span class="sensor-stat-value">${formatNumber(sensor.bandwidth || 0, 1)} Mbps</span>
                            </div>
                            <div class="sensor-stat">
                                <span class="sensor-stat-label">Alerts 24h</span>
                                <span class="sensor-stat-value">${sensor.alerts_24h || 0}</span>
                            </div>
                        </div>
                    </div>
                `).join('');

                return `
                    <div class="location-group">
                        <div class="location-group-header">
                            <span class="location-name">üìç ${escapeHtml(location)}</span>
                            <span class="location-count">${locationSensors.length} sensor${locationSensors.length !== 1 ? 's' : ''}</span>
                        </div>
                        <div class="sensors-grid">
                            ${sensorsHTML}
                        </div>
                    </div>
                `;
            }).join('');

            document.getElementById('location-groups').innerHTML = locationsHTML;
        }

        function formatThreatName(type) {
            // Convert UPPERCASE_WITH_UNDERSCORES to Title Case
            return type
                .split('_')
                .map(word => word.charAt(0) + word.slice(1).toLowerCase())
                .join(' ');
        }

        function updateThreatBreakdown(threats) {
            const threatList = document.getElementById('threat-list');
            if (!threatList) return;

            if (!threats || Object.keys(threats).length === 0) {
                threatList.innerHTML = `
                    <div class="card" style="text-align: center; padding: 2rem;">
                        <div style="font-size: 3rem; margin-bottom: 1rem;">‚úÖ</div>
                        <h3 style="color: var(--accent-success);">No Threats Detected</h3>
                        <p style="color: var(--text-muted); margin-top: 0.5rem;">System operating normally</p>
                    </div>
                `;
                return;
            }

            // Convert to array and sort by count
            const threatArray = Object.entries(threats)
                .map(([type, count]) => ({ type, count }))
                .sort((a, b) => b.count - a.count)
                .slice(0, 5);  // Top 5 threats

            const maxCount = Math.max(...threatArray.map(t => t.count), 1);

            const threatsHTML = threatArray.map(threat => {
                const icon = THREAT_ICONS[threat.type] || THREAT_ICONS['UNKNOWN'];
                const barWidth = (threat.count / maxCount) * 100;
                const displayName = formatThreatName(threat.type);

                return `
                    <div class="threat-item">
                        <div class="threat-info">
                            <div class="threat-icon">${icon}</div>
                            <div class="threat-details">
                                <div class="threat-name">${escapeHtml(displayName)}</div>
                                <div class="threat-bar">
                                    <div class="threat-bar-fill" style="width: ${barWidth}%;"></div>
                                </div>
                            </div>
                        </div>
                        <div class="threat-count">${threat.count}</div>
                    </div>
                `;
            }).join('');

            threatList.innerHTML = threatsHTML;
        }

        function updateLocationGroups(sensors) {
            const locationGroupsEl = document.getElementById('location-groups');
            if (!locationGroupsEl) return;

            if (sensors.length === 0) {
                locationGroupsEl.innerHTML = '';
                return;
            }

            // Group sensors by location
            const locationMap = {};
            sensors.forEach(sensor => {
                const location = sensor.location || 'Unknown';
                if (!locationMap[location]) {
                    locationMap[location] = {
                        total: 0,
                        online: 0,
                        warning: 0,
                        offline: 0
                    };
                }
                locationMap[location].total++;
                locationMap[location][sensor.status]++;
            });

            // Generate HTML for location groups
            const locationsHTML = Object.entries(locationMap).map(([location, stats]) => {
                let statusColor = 'var(--accent-success)';
                let statusText = 'All Online';

                if (stats.offline > 0) {
                    statusColor = 'var(--accent-danger)';
                    statusText = `${stats.offline} Offline`;
                } else if (stats.warning > 0) {
                    statusColor = 'var(--accent-warning)';
                    statusText = `${stats.warning} Warning`;
                }

                return `
                    <div class="location-group">
                        <div class="location-group-header">
                            <div class="location-name">üìç ${escapeHtml(location)}</div>
                            <div class="location-count" style="color: ${statusColor}; font-weight: 600;">
                                ${stats.online}/${stats.total}
                            </div>
                        </div>
                        <div style="font-size: 0.75rem; color: var(--text-muted);">
                            ${statusText}
                        </div>
                    </div>
                `;
            }).join('');

            locationGroupsEl.innerHTML = locationsHTML;
        }

        function updateTimestamp() {
            const now = new Date();
            const timeStr = now.toLocaleTimeString('nl-NL');
            document.getElementById('timestamp').textContent = timeStr;
        }

        // ==================== Utility Functions ====================
        function formatNumber(num, decimals = 0) {
            return Number(num).toFixed(decimals);
        }

        function formatTimestamp(timestamp) {
            if (!timestamp) return 'N/A';
            const date = new Date(timestamp);
            return date.toLocaleTimeString('nl-NL', { hour: '2-digit', minute: '2-digit' });
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function getAlertColor(rate) {
            if (rate === 0) return 'online';
            if (rate < 1) return 'warning';
            return 'critical';
        }

        function getSensorHealthColor(health) {
            if (!health || health.total === 0) return 'offline';
            const onlinePercent = (health.online / health.total) * 100;
            if (onlinePercent === 100) return 'online';
            if (onlinePercent >= 80) return 'warning';
            return 'critical';
        }

        function getResourceColor(percent) {
            if (percent < 70) return 'online';
            if (percent < 85) return 'warning';
            return 'critical';
        }

        // ==================== Traffic Chart ====================
        let trafficChart = null;

        async function fetchTrafficData() {
            try {
                const response = await fetch('/api/kiosk/traffic');
                const data = await response.json();

                if (data.success) {
                    updateTrafficChart(data);
                }
            } catch (error) {
                console.error('Error fetching traffic data:', error);
            }
        }

        // Calculate a good Y-axis max for the traffic chart
        function calculateSuggestedMax(inboundData, outboundData) {
            // Find the maximum value in both datasets
            const allValues = [...(inboundData || []), ...(outboundData || [])];
            const maxValue = Math.max(...allValues, 0);

            // More granular scaling for low bandwidth to show detail
            if (maxValue < 0.05) {
                return 0.1; // Show 0-0.1 Mbps scale for very low traffic
            } else if (maxValue < 0.2) {
                return 0.5; // Show 0-0.5 Mbps scale
            } else if (maxValue < 0.5) {
                return 1; // Show 0-1 Mbps scale
            } else if (maxValue < 1) {
                return 2; // Show 0-2 Mbps scale
            }

            // Round up to a nice number for the scale
            // This creates nice intervals like 2, 5, 10, 20, 50, 100, etc.
            const magnitude = Math.pow(10, Math.floor(Math.log10(maxValue)));
            const normalized = maxValue / magnitude;

            let niceMax;
            if (normalized <= 1) niceMax = 1;
            else if (normalized <= 2) niceMax = 2;
            else if (normalized <= 5) niceMax = 5;
            else niceMax = 10;

            return niceMax * magnitude * 1.1; // Add 10% padding
        }

        function updateTrafficChart(data) {
            const ctx = document.getElementById('trafficChart');
            if (!ctx) return;

            // Get current theme
            const theme = document.documentElement.getAttribute('data-theme');
            const isDark = theme === 'dark';

            // Chart colors
            const gridColor = isDark ? 'rgba(71, 85, 105, 0.3)' : 'rgba(226, 232, 240, 0.8)';
            const textColor = isDark ? '#cbd5e1' : '#475569';

            // Destroy old chart if exists
            if (trafficChart) {
                trafficChart.destroy();
            }

            // Create new chart
            trafficChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: data.labels,
                    datasets: [
                        {
                            label: 'Inbound',
                            data: data.datasets.bandwidth_in,
                            borderColor: '#3b82f6',
                            backgroundColor: 'rgba(59, 130, 246, 0.1)',
                            borderWidth: 2,
                            fill: true,
                            tension: 0.4,
                            pointRadius: 0,
                            pointHoverRadius: 4,
                            pointHoverBackgroundColor: '#3b82f6'
                        },
                        {
                            label: 'Outbound',
                            data: data.datasets.bandwidth_out,
                            borderColor: '#10b981',
                            backgroundColor: 'rgba(16, 185, 129, 0.1)',
                            borderWidth: 2,
                            fill: true,
                            tension: 0.4,
                            pointRadius: 0,
                            pointHoverRadius: 4,
                            pointHoverBackgroundColor: '#10b981'
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: {
                        mode: 'index',
                        intersect: false
                    },
                    plugins: {
                        legend: {
                            display: false  // Using custom legend
                        },
                        tooltip: {
                            backgroundColor: isDark ? '#1e293b' : '#ffffff',
                            titleColor: textColor,
                            bodyColor: textColor,
                            borderColor: gridColor,
                            borderWidth: 1,
                            padding: 12,
                            displayColors: true,
                            callbacks: {
                                label: function(context) {
                                    return context.dataset.label + ': ' + context.parsed.y.toFixed(2) + ' Mbps';
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            grid: {
                                color: gridColor,
                                drawBorder: false
                            },
                            ticks: {
                                color: textColor,
                                maxRotation: 0,
                                autoSkipPadding: 20
                            }
                        },
                        y: {
                            beginAtZero: true,
                            suggestedMax: calculateSuggestedMax(data.datasets.bandwidth_in, data.datasets.bandwidth_out),
                            grid: {
                                color: gridColor,
                                drawBorder: false
                            },
                            ticks: {
                                color: textColor,
                                callback: function(value) {
                                    // Show 2 decimals for low bandwidth, 1 decimal for higher
                                    const decimals = value < 1 ? 2 : 1;
                                    return value.toFixed(decimals) + ' Mbps';
                                }
                            }
                        }
                    }
                }
            });
        }

        // ==================== Auto Refresh ====================
        function startAutoRefresh() {
            // Initial fetch
            fetchMetrics();
            fetchSensors();
            fetchTrafficData();

            // Set up refresh interval
            refreshTimer = setInterval(() => {
                fetchMetrics();
                fetchSensors();
                fetchTrafficData();
            }, CONFIG.refreshInterval);
        }

        function stopAutoRefresh() {
            if (refreshTimer) {
                clearInterval(refreshTimer);
                refreshTimer = null;
            }
        }

        // ==================== Initialization ====================
        document.addEventListener('DOMContentLoaded', () => {
            // Initialize theme
            initTheme();

            // Show fullscreen hint
            setTimeout(showFullscreenHint, 1000);

            // Start auto-refresh
            startAutoRefresh();

            // Start screen rotation
            startRotation();

            // Update timestamp every second
            setInterval(updateTimestamp, 1000);

            // Keyboard shortcuts
            document.addEventListener('keydown', (e) => {
                if (e.key === 'F11') {
                    e.preventDefault();
                    toggleFullscreen();
                } else if (e.key === 't' || e.key === 'T') {
                    toggleTheme();
                } else if (e.key === 'ArrowRight' || e.key === ' ') {
                    e.preventDefault();
                    nextScreen();
                }
            });

            // Click to advance to next screen
            document.addEventListener('click', (e) => {
                // Don't advance if clicking on interactive elements
                if (e.target.tagName === 'BUTTON' || e.target.tagName === 'A' || e.target.closest('button') || e.target.closest('a')) {
                    return;
                }
                nextScreen();
            });
        });

        // Clean up on page unload
        window.addEventListener('beforeunload', () => {
            stopAutoRefresh();
            stopRotation();
        });
    </script>
</body>
</html>
